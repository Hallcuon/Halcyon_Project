from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status
from django.db.models import Count, Q
from .models import Placemark, Beacon, BeaconContent, AnonymousMessage, ActivatedBeacon, Comment, FoundAnonymousMessage, Profile, ChatMessage
from .serializers import (
    PlacemarkSerializer,
    BeaconSerializer,
    BeaconContentSerializer,
    UserSerializer,
    UserStatsSerializer,
    AnonymousMessageSerializer,
    CommentSerializer, ProfileSerializer,
    ProfileSerializer,
    ChatMessageSerializer,
)
from rest_framework import permissions
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from django.contrib.auth.models import User
import random
from django.utils import timezone
from datetime import timedelta
import os
from rest_framework.pagination import PageNumberPagination

class ChatMessagePagination(PageNumberPagination):
    page_size = 50
    page_size_query_param = 'page_size'
    max_page_size = 100

class IsAuthorOrReadOnly(permissions.BasePermission):
    """
    Custom permission to only allow authors of an object to edit or delete it.
    """
    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed for any request (GET, HEAD, OPTIONS).
        if request.method in permissions.SAFE_METHODS:
            return True
        # Write permissions are only allowed to the author of the comment.
        return obj.author == request.user

# Create your views here.
class PlacemarkViewSet(viewsets.ModelViewSet):
    serializer_class = PlacemarkSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        """
        This view should return a list of all placemarks
        for the currently authenticated user.
        """
        return Placemark.objects.filter(owner=self.request.user)

    def perform_create(self, serializer):
        """Associates the placemark with the logged-in user upon creation."""
        serializer.save(owner=self.request.user)


class PublicPlacemarkViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint that allows public placemarks (not owned by the current user) to be viewed.
    """
    serializer_class = PlacemarkSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        # The user sees placemarks of all other users, but not their own.
        return Placemark.objects.exclude(owner=self.request.user)

class AnonymousMessageViewSet(viewsets.ModelViewSet):
    """
    API for anonymous messages ("paper planes").
    GET - retrieve all available messages.
    POST - create a new one (coordinates are generated by the server).
    """
    serializer_class = AnonymousMessageSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if not user or not user.is_authenticated:
            # This case should be handled by permission_classes, but for robustness,
            # return an empty queryset for anonymous users to avoid errors.
            return AnonymousMessage.objects.none()

        # A message is considered "active" if it has not been found by anyone yet.
        # Once a user finds a message, it disappears for everyone.

        # Get IDs of all messages that have been found by at least one user.
        found_message_ids = FoundAnonymousMessage.objects.values_list('message_id', flat=True).distinct()

        # Return all messages that are not in the list of found messages.
        return AnonymousMessage.objects.exclude(id__in=found_message_ids)

    def perform_create(self, serializer):
        # Generate random coordinates before saving.
        latitude = random.uniform(-90, 90)
        longitude = random.uniform(-180, 180)
        serializer.save(latitude=latitude, longitude=longitude, owner=self.request.user)

    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def found(self, request, pk=None):
        message = self.get_object()
        user = request.user

        if message.owner == user:
            return Response({'detail': 'You cannot find your own message.'}, status=status.HTTP_400_BAD_REQUEST)

        # get_or_create returns a tuple (object, created_boolean)
        obj, created = FoundAnonymousMessage.objects.get_or_create(user=user, message=message)

        if not created:
            return Response({'detail': 'Message already found by this user.'}, status=status.HTTP_400_BAD_REQUEST)

        # Award 25 XP only if the message is found for the first time.
        request.user.profile.add_xp(25)
        
        return Response({'status': 'message marked as found', 'xp_gained': 25}, status=status.HTTP_200_OK)

class BeaconViewSet(viewsets.ModelViewSet):
    queryset = Beacon.objects.all()
    serializer_class = BeaconSerializer
    permission_classes = [permissions.IsAuthenticated]

    @action(detail=True, methods=['post'])
    def activate(self, request, pk=None):
        beacon = self.get_object()
        user = request.user

        # Check if the user has already activated this beacon.
        if ActivatedBeacon.objects.filter(user=user, beacon=beacon).exists():
            return Response({'detail': 'You have already activated this beacon.'}, status=status.HTTP_400_BAD_REQUEST)

        # If the check passes, activate the beacon for the user.
        ActivatedBeacon.objects.create(user=user, beacon=beacon)
        
        # Award 50 XP for activating a beacon.
        request.user.profile.add_xp(50)

        serializer = self.get_serializer(beacon)
        # Add information about the experience gained to the response.
        data = serializer.data
        data['xp_gained'] = 50
        return Response(data, status=status.HTTP_200_OK)

class CommunityProgressView(viewsets.ViewSet):
    permission_classes = [permissions.IsAuthenticated]

    def list(self, request):
        total_beacons = Beacon.objects.count()
        if total_beacons == 0:
            return Response({'activated': 0, 'total': 0, 'progress': 0})

        activated_count = ActivatedBeacon.objects.values('beacon').distinct().count()
        progress = (activated_count / total_beacons) * 100
        return Response({'activated': activated_count, 'total': total_beacons, 'progress': progress})

class LeaderboardView(viewsets.ViewSet):
    """
    Provides a list of top users based on the number of activated beacons.
    """
    permission_classes = [permissions.IsAuthenticated]

    def list(self, request):
        # Annotate profiles with the count of distinct activated beacons
        leaderboard_data = Profile.objects.annotate(
            activated_beacons_count=Count('user__activatedbeacon', distinct=True)
        ).filter(
            activated_beacons_count__gt=0  # Only include users who have activated at least one beacon
        ).order_by('-activated_beacons_count').select_related('user')[:10] # Get top 10 users

        # Manually serialize the data to include necessary fields
        result = [
            {
                'username': profile.user.username,
                'avatar_url': request.build_absolute_uri(profile.avatar.url),
                'activated_beacons_count': profile.activated_beacons_count
            } for profile in leaderboard_data
        ]
        return Response(result)

class BeaconContentViewSet(viewsets.ModelViewSet):
    queryset = BeaconContent.objects.all()
    serializer_class = BeaconContentSerializer
    permission_classes = [permissions.AllowAny]  # Beacon content is public for now.


class UserViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows users to be viewed or edited.
    Used for user registration.
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [permissions.AllowAny]  # Allow anyone to register.


class CommentViewSet(viewsets.ModelViewSet):
    serializer_class = CommentSerializer
    permission_classes = [IsAuthorOrReadOnly]
    
    def get_serializer_context(self):
        """Pass the request to the serializer context."""
        context = super().get_serializer_context()
        context['request'] = self.request
        return context

    def get_queryset(self):
        # Filter comments by the placemark ID from the URL.
        return Comment.objects.filter(placemark_id=self.kwargs['placemark_pk'])

    def perform_create(self, serializer):
        # Automatically set the author and placemark on creation.
        serializer.save(author=self.request.user, placemark_id=self.kwargs['placemark_pk'])


class UserStatsViewSet(viewsets.ViewSet):
    permission_classes = [permissions.IsAuthenticated]

    def list(self, request):
        user = request.user
        # get_or_create ensures that the profile exists.
        profile, _ = Profile.objects.get_or_create(user=user)
        # Pass 'request' to the context so the serializer can build full URLs.
        serializer = UserStatsSerializer(profile, context={'request': request})
        return Response(serializer.data)


class ProfileViewSet(viewsets.ModelViewSet):
    queryset = Profile.objects.all()
    serializer_class = ProfileSerializer
    permission_classes = [permissions.IsAuthenticated]
    lookup_field = 'user__username' # Allows finding profiles by username from the URL.
    parser_classes = (MultiPartParser, FormParser, JSONParser) # Allows file uploads and JSON data.

    def get_queryset(self):
        # Users can only view and edit their own profile.
        return Profile.objects.filter(user=self.request.user)

    @action(detail=True, methods=['post'])
    def delete_avatar(self, request, user__username=None):
        # get_object() uses the 'user__username' lookup_field to find the profile.
        profile = self.get_object()
        
        default_avatar_name = 'avatars/DefaultProfile.png'
        
        # Check if the current avatar is not the default one.
        if profile.avatar and profile.avatar.name != default_avatar_name:
            old_avatar_path = profile.avatar.path
            
            profile.avatar.name = default_avatar_name
            profile.save()
            
            if os.path.isfile(old_avatar_path):
                os.remove(old_avatar_path)
        
        serializer = self.get_serializer(profile)
        return Response(serializer.data)


class OnlineUsersViewSet(viewsets.ViewSet):
    permission_classes = [permissions.IsAuthenticated]

    def list(self, request):
        # Users who have been active within the last 5 minutes.
        five_minutes_ago = timezone.now() - timedelta(minutes=5)
        online_profiles = Profile.objects.filter(last_seen__gte=five_minutes_ago).select_related('user')

        online_users_data = []
        for profile in online_profiles:
            online_users_data.append({
                'username': profile.user.username,
                # Build a full, absolute URL for the avatar.
                'avatar_url': request.build_absolute_uri(profile.avatar.url),
                'chat_color': profile.chat_color
            })

        return Response({
            'online_count': len(online_users_data),
            'users': online_users_data
        })

class ChatMessageViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = ChatMessage.objects.all().order_by('-timestamp')
    serializer_class = ChatMessageSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = ChatMessagePagination
    
    def get_serializer_context(self):
        """Pass the request to the serializer context."""
        context = super().get_serializer_context()
        context['request'] = self.request
        return context
